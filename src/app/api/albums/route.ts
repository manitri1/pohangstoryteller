import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { AlbumClassifier } from '@/lib/album-classifier';

// 이 라우트를 동적으로 설정
export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();

    // 사용자 인증 확인
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: '인증이 필요합니다.' },
        { status: 401 }
      );
    }

    // 앨범 조회
    const { data: albums, error: albumsError } = await supabase
      .from('albums')
      .select(
        `
        id,
        title,
        description,
        cover_image_url,
        theme,
        is_public,
        is_auto_generated,
        created_at,
        updated_at,
        album_items (
          id,
          item_type,
          title,
          content_url,
          thumbnail_url,
          metadata,
          sort_order
        )
      `
      )
      .eq('user_id', user.id)
      .order('created_at', { ascending: false });

    if (albumsError) {
      console.error('앨범 조회 오류:', albumsError);
      return NextResponse.json(
        { error: '앨범 데이터를 불러올 수 없습니다.' },
        { status: 500 }
      );
    }

    // 앨범 통계 조회
    const { data: stats, error: statsError } = await supabase
      .from('user_album_stats')
      .select('*')
      .eq('user_id', user.id)
      .single();

    if (statsError) {
      console.error('통계 조회 오류:', statsError);
    }

    // 앨범 데이터 변환
    const transformedAlbums =
      albums?.map((album) => ({
        id: album.id,
        title: album.title,
        description: album.description,
        coverImageUrl: album.cover_image_url,
        theme: album.theme,
        isPublic: album.is_public,
        isAutoGenerated: album.is_auto_generated,
        itemCount: album.album_items?.length || 0,
        viewCount: 0, // TODO: 실제 조회수 구현
        likeCount: 0, // TODO: 실제 좋아요 수 구현
        createdAt: album.created_at,
        updatedAt: album.updated_at,
        items:
          album.album_items?.map((item) => ({
            id: item.id,
            type: item.item_type,
            title: item.title,
            contentUrl: item.content_url,
            thumbnailUrl: item.thumbnail_url,
            metadata: item.metadata,
          })) || [],
      })) || [];

    return NextResponse.json({
      albums: transformedAlbums,
      stats: stats || {
        total_albums: 0,
        total_items: 0,
        auto_albums: 0,
        public_albums: 0,
        total_views: 0,
        total_likes: 0,
      },
    });
  } catch (error) {
    console.error('API 오류:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // 사용자 인증 확인
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: '인증이 필요합니다.' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { title, description, theme, isPublic, items, isAutoGenerated } =
      body;

    if (!title) {
      return NextResponse.json(
        { error: '앨범 제목이 필요합니다.' },
        { status: 400 }
      );
    }

    // 앨범 생성
    const { data: newAlbum, error: albumError } = await supabase
      .from('albums')
      .insert({
        user_id: user.id,
        title,
        description,
        theme: theme || 'general',
        is_public: isPublic || false,
        is_auto_generated: isAutoGenerated || false,
      })
      .select()
      .single();

    if (albumError) {
      console.error('앨범 생성 오류:', albumError);
      return NextResponse.json(
        { error: '앨범 생성에 실패했습니다.' },
        { status: 500 }
      );
    }

    // 앨범 아이템 추가
    if (items && items.length > 0) {
      const albumItems = items.map((item: any, index: number) => ({
        album_id: newAlbum.id,
        item_type: item.type,
        content_id: item.contentId,
        title: item.title,
        description: item.description,
        content_url: item.contentUrl,
        thumbnail_url: item.thumbnailUrl,
        metadata: item.metadata,
        sort_order: index,
      }));

      const { error: itemsError } = await supabase
        .from('album_items')
        .insert(albumItems);

      if (itemsError) {
        console.error('앨범 아이템 생성 오류:', itemsError);
      }
    }

    return NextResponse.json({
      success: true,
      album: {
        id: newAlbum.id,
        title: newAlbum.title,
        description: newAlbum.description,
        theme: newAlbum.theme,
        isPublic: newAlbum.is_public,
        isAutoGenerated: newAlbum.is_auto_generated,
        createdAt: newAlbum.created_at,
      },
    });
  } catch (error) {
    console.error('API 오류:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}

// 앨범 자동 생성 API
export async function PUT(request: NextRequest) {
  try {
    const supabase = await createClient();

    // 사용자 인증 확인
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    if (authError || !user) {
      return NextResponse.json(
        { error: '인증이 필요합니다.' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { classificationType } = body; // 'date', 'location', 'theme', 'smart'

    // 사용자의 스탬프와 미디어 파일 조회
    const { data: stamps, error: stampsError } = await supabase
      .from('user_stamps')
      .select(
        `
        id,
        acquired_at,
        rarity,
        points,
        locations!inner(
          id,
          name,
          description,
          image_url,
          coordinates
        )
      `
      )
      .eq('user_id', user.id)
      .order('acquired_at', { ascending: false });

    if (stampsError) {
      console.error('스탬프 조회 오류:', stampsError);
      return NextResponse.json(
        { error: '스탬프 데이터를 불러올 수 없습니다.' },
        { status: 500 }
      );
    }

    // 미디어 파일 조회
    const { data: mediaFiles, error: mediaError } = await supabase
      .from('media_files')
      .select(
        `
        id,
        file_name,
        file_type,
        file_url,
        thumbnail_url,
        metadata,
        captured_at,
        locations (
          id,
          name,
          description
        )
      `
      )
      .eq('user_id', user.id)
      .order('captured_at', { ascending: false });

    if (mediaError) {
      console.error('미디어 파일 조회 오류:', mediaError);
    }

    // 앨범 분류기 초기화
    const classifier = new AlbumClassifier();

    // 아이템 데이터 변환
    const items = [
      ...(stamps || []).map((stamp) => ({
        id: stamp.id,
        type: 'stamp' as const,
        title: stamp.locations[0]?.name || '알 수 없는 위치',
        contentUrl: stamp.locations[0]?.image_url,
        metadata: {
          location: stamp.locations[0]?.name || '알 수 없는 위치',
          timestamp: stamp.acquired_at,
          tags: ['스탬프', stamp.rarity],
          coordinates: stamp.locations[0]?.coordinates,
        },
      })),
      ...(mediaFiles || []).map((media) => ({
        id: media.id,
        type: media.file_type.startsWith('image/')
          ? ('photo' as const)
          : ('video' as const),
        title: media.file_name,
        contentUrl: media.file_url,
        metadata: {
          location: media.locations?.[0]?.name,
          timestamp: media.captured_at,
          tags: ['미디어'],
          duration: media.metadata?.duration,
          fileSize: media.metadata?.fileSize,
        },
      })),
    ];

    let albums = [];

    // 분류 타입에 따른 앨범 생성
    switch (classificationType) {
      case 'date':
        albums = classifier.classifyByDate(items);
        break;
      case 'location':
        albums = classifier.classifyByLocation(items);
        break;
      case 'theme':
        albums = classifier.classifyByTheme(items);
        break;
      case 'smart':
        albums = classifier.generateSmartAlbums(items);
        break;
      default:
        albums = classifier.classifyByDate(items);
    }

    // 생성된 앨범들을 데이터베이스에 저장
    const savedAlbums = [];
    for (const album of albums) {
      const { data: newAlbum, error: albumError } = await supabase
        .from('albums')
        .insert({
          user_id: user.id,
          title: album.title,
          description: album.description,
          theme: album.theme,
          is_auto_generated: true,
          generation_trigger: classificationType,
        })
        .select()
        .single();

      if (albumError) {
        console.error('앨범 생성 오류:', albumError);
        continue;
      }

      // 앨범 아이템 저장
      const albumItems = album.items.map((item, index) => ({
        album_id: newAlbum.id,
        item_type: item.type,
        content_id: item.id,
        title: item.title,
        content_url: item.contentUrl,
        metadata: item.metadata,
        sort_order: index,
      }));

      const { error: itemsError } = await supabase
        .from('album_items')
        .insert(albumItems);

      if (itemsError) {
        console.error('앨범 아이템 생성 오류:', itemsError);
      }

      savedAlbums.push({
        id: newAlbum.id,
        title: newAlbum.title,
        description: newAlbum.description,
        theme: newAlbum.theme,
        itemCount: album.items.length,
        classificationReason: album.classificationReason,
      });
    }

    return NextResponse.json({
      success: true,
      albums: savedAlbums,
      message: `${savedAlbums.length}개의 앨범이 자동 생성되었습니다.`,
    });
  } catch (error) {
    console.error('API 오류:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
